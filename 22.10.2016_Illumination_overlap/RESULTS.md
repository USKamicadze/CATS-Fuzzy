

Вспомогательные инструменты
---------------
Имеем набор .sh и .js скриптов для упрощения работы (некоторые из них уже давно следует переименовать или объединить):

1. download.js - скрипт для Greasemonkey, добавляющий кнопку для скачивания решений на С++ находящихся на экране консоли(https://imcs.dvfu.ru/cats/main.pl?f=console), решения скачиваются в папку загрузок браузера по умолчанию в формате `CATS#solution#{problemname}#{rid}#{status}.cpp` - пример: `CATS#solution#Illumination_overlap#1025781#WAOT2.cpp`
2. not_prepared.sh - производит первичную предобработку файлов - копирует решения из папки not_prepared в папку solutions заменяя `#` на `__`(да, это два подчерка)  (как оказалось использовать `#` в качестве разделителя в имени было плохой идеей cmake такие файлы плохо распознает) 
3. convert_solution.pl - набор эвристических регулярок (часто) преобразующие решение к компилируемому виду. В output печатает результат. 
4. prepare.sh - подготавливает решения из папки solutions для фазинга в папке works. 
Каждое подготовленное решение имеет следующую структуру: checker.cpp, checker.h, CMakeLists.txt (используется для дебага), in/ (начальные тесты), main (executable), out/ (результаты afl), post_lib.so, run.cpp (содержит main), solution.cpp, solution.h
Параметры: 
	- checker - ну тут вроде понятно
	- post_lib_source - исходник на языке СИ, компилируемый в .so используется для обработки теста перед запуском на нем тестируемой программы. Больше информации можно найти в %aflsource%/experimental/post_library.
	- run - путь до файла запускающий решение и чекер. Обычно имеет вид 
	
		```
		int main() {
		   solution();
		   checker();
		}
		```
	- afl - путь до компилятора afl-g++
5. run_work.sh - принимает путь до папки с подготовленным решением, запускает afl-fuzz.


----------


Возникшие проблемы
-------------
1. Решения большинства участников написаны на Visual Studio и не компилируются под gcc.
	Частичное решение: регулярка. см. convert_solution.pl
2. afl работает только с одним исполняемым файлом и не различает solution и checker.
	Текущее решение: склеить из soultion и checker одну программу.
3. Вытекает из предыдущего решения -> Когда checker пытается считать output.txt то считываются одни нули. Эффект получился в результате того что после отработки soulution() не происходит fflush для output.txt - обычно это происходило по завершению программы. 
	Текущее решение: неизвестно.

----------

Результаты 22.10.2015
---------
Illumination overlap.
Компилируется и тестируются большинство решений под afl за счет регулярки (convert_solution.pl) подменяющей cin, cont и freopen.  Ни в одном SA решении ошибок не обнаружено.

После того как я все таки отладил post_lib.c Генерация новых тестов упала в разы. Очевидно данные не проходят валидацию и выходят за необходимые пределы. Идея со сжатием данных прозвучавшая на прошлой неделе сейчас выглядит вполне неплохо. На текущий момент за 18 минут сгенерировано 1300 тестов и это для задачи где у нас есть всего 2 числа. При более сложных ограничениях мы видимо совсем застопоримся. 

Есть другая идея. Воткнуть post_lib прям в тестируемый исходник и тогда  по идее afl будет пытаться искать новые пути которые проходят валидацию. Тогда main грубо будет выглядеть так 

```
int main() {
	readBitsAndGenerateValidInputAndWriteItToInputTXT();
	solve();
	check();
}
```

